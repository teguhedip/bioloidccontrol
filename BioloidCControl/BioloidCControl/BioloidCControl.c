/*
 * BioloidCControl.c - Replacement firmware for the Robotis Bioloid CM-510 controller
 *   and Bioloid Premium Kit based humanoid robots (Type A/B/C). 
 * 
 * Requires a motion.h file generated by the translate_motion.pl Perl script.
 *
 * Supports all motions, including walking, gyro, DMS, buzzer, LEDs, buttons and
 * serial connection via cable and ZIG2Serial.
 *   
 * Performs initializations and then runs main control loop
 *   
 * Version 0.8		1/03/2013 - command sequences
 *
 * Written by Peter Lanius
 * Please send suggestions and bug fixes to PeterLanius@gmail.com
 *
 */

/*
 * You may freely modify and share this code, as long as you keep this
 * notice intact. Licensed under the Creative Commons BY-SA 3.0 license:
 *
 *   http://creativecommons.org/licenses/by-sa/3.0/
 *
 * Disclaimer: To the extent permitted by law, this work is provided
 * without any warranty. It might be defective, in which case you agree
 * to be responsible for all resulting costs and damages.
 */

#include <avr/io.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "global.h"			// modify settings for your robot here
#include "buzzer.h"
#include "button.h"
#include "led.h"
#include "serial.h"			// contains the command strings recognized
#include "adc.h"
#include "dynamixel.h"
#include "pose.h"
#include "motion_f.h"
#include "clock.h"
#include "walk.h"
#include "pid.h"
#include "balance.h"

// Array showing which Dynamixel servos are enabled (ID from 0 to 25)
#ifdef HUMANOID_TYPEA
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEB
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEC
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,9,10,11,12,13,14,15,16,17,18};
#endif

// store the buzzer melodies in Flash
const char melody1[] PROGMEM = "!L16 cdefgab>cbagfedc";
const char melody2[] PROGMEM = "T240 L8 a gafaeada c+adaeafa";
const char melody3[] PROGMEM = "O6 T40 L16 d#<b<f#<d#<f#<bd#f#";
const char melody4[] PROGMEM = "! O6 L16 dcd<b-d<ad<g d<f+d<gd<ad<b-";
const char melody5[] PROGMEM = "! O3 T40 f.b.f.b.f.b.f.b.";
 
// Define global variables for use in the ISRs
// Button related variables
volatile bool button_up_pressed = FALSE;
volatile bool button_down_pressed = FALSE;
volatile bool button_left_pressed = FALSE;
volatile bool button_right_pressed = FALSE;
volatile bool start_button_pressed = FALSE;

// Buzzer related global variables
volatile unsigned char buzzerFinished = 0;	// flag: 0 while playing
const char *buzzerSequence;

// ADC related global variables 
// By default ports are assigned as follows:
//		GyroX = CM-510 Port3 = ADC3 = PORTF3
//		GyroY = CM-510 Port4 = ADC4 = PORTF4
//		DMS   = CM-510 Port5 = ADC5 = PORTF5
//		AccelY= CM-510 Port1 = ADC1 = PORTF0
//		AccelX= CM-510 Port2 = ADC2 = PORTF1
//		Ultra = CM-510 Port6 = ADC6 = PORTF5
#ifdef ACCEL_AND_ULTRASONIC
volatile uint8 adc_sensor_enable[ADC_CHANNELS] = {1, 1, 1, 1, 1, 1}; 
#endif
#ifdef GYRO_AND_DMS_ONLY
volatile uint8 adc_sensor_enable[ADC_CHANNELS] = {0, 0, 1, 1, 1, 0}; 
#endif
volatile int16 adc_sensor_val[ADC_CHANNELS] = {0, 0, 0, 0, 0, 0}; 	// array of sensor values
volatile uint16 adc_battery_val = 0;		// battery voltage in millivolts
volatile uint16 adc_gyrox_center = 0;		// gyro x center value
volatile uint16 adc_gyroy_center = 0;		// gyro y center value
volatile int16 adc_accelx = 0;				// accelerometer x value
volatile int16 adc_accely = 0;				// accelerometer y value
volatile uint16 adc_accelx_center = 0;		// accelerometer x center value
volatile uint16 adc_accely_center = 0;		// accelerometer y center value
volatile uint16 adc_ultrasonic_distance = 0;	// ultrasonic distance sensor value
volatile uint16 adc_dms_distance = 0;		// DMS sensor distance value

// Global variables related to the finite state machine that governs execution
volatile uint8 bioloid_command = 0;			// current command
volatile uint8 last_bioloid_command = 0;	// last command
volatile bool  new_command = FALSE;			// flag that we got a new command
volatile uint8 flag_receive_ready = 0;		// received complete command flag
volatile bool  major_alarm = FALSE;			// Major alarms that should stop execution

// keep the current pose and joint offsets as global variables
volatile int16 current_pose[NUM_AX12_SERVOS];
volatile int16 joint_offset[NUM_AX12_SERVOS];
// arrays that indicate which servos move in each step/motion page
volatile uint8 motion_step_servos_moving[MAX_MOTION_STEPS][NUM_AX12_SERVOS];
volatile uint8 motion_servos_moving[NUM_AX12_SERVOS];

// and also the current and next motion pages
volatile uint8 current_motion_page = 0;
volatile uint8 next_motion_page = 0;		// next motion page if we got new command
volatile uint8 current_step = 0;			// number of the current motion page step

// Input, Output and Setpoint variables for the PID controller (x and y-axis)
volatile double pid_input[PID_DIMENSION] = { 0.0, 0.0 };
volatile double pid_output[PID_DIMENSION] = { 0.0, 0.0 };
volatile double pid_setpoint[PID_DIMENSION] = { 0.0, 0.0 };


// the new implementation of AVR libc does not allow variables passed to _delay_ms
static inline void delay_ms(uint16 count) {
	while(count--) { 
		_delay_ms(1); 
	} 
}


int main(void)
{
	// local variables
	int		sensor_flag, command_flag, comm_status, sensor_process_flag, obstacle_flag, wait_flag;
	unsigned long wait_timer = 0; 
	unsigned long wait_time = 0;
	uint8	motion_flag = 0;
	
	// TIMING: unsigned long timer1, timer2, timer3, timer4;
	
	// Initialization Routines
	led_init();				// switches all 6 LEDs on
	serial_init(57600);		// serial port at 57600 baud
	buzzer_init();			// enable buzzer melodies
	button_init();			// enable push buttons on CM-510
	delay_ms(200);			// wait 0.2s 
	led_off(ALL_LED);		// and switch them back off
	
	// initialize the clock
	clock_init();
	wait_flag = 0;
	
	// enable interrupts
	sei();
	// print welcome message
	printf("\nBioloid C Control V0.8\n");
	printf("Press the START button on the CM-510 to continue.\n");
	// reset the start button variable, something triggers the interrupt on start-up
	start_button_pressed = FALSE;
	
	// initialize motion pages
	motionPageInit();
	
	// Wait for the START Button before going any further
	while(!start_button_pressed)
	{
		// PLAY LED is flashing at 5Hz
		led_toggle(LED_PLAY);
		delay_ms(200);
	}
	// Now turn LED solid
	led_on(LED_PLAY);
	// and reset the start button variable
	start_button_pressed = FALSE;

	// perform high level initialization of Dynamixel bus and servos
	dxl_init(DEFAULT_BAUDNUMBER);

	// assume initial pose
	executeMotion(COMMAND_BALANCE_MP);
	
	// set the walk state
	walk_setWalkState(0);
	obstacle_flag = 0;
	
	// initialize the PID controller for balancing
#ifdef ACCEL_AND_ULTRASONIC
	pid_init();
	setupGyroKalman();
#endif

	// initialize the ADC and take default readings
	delay_ms(4000);			// wait 4s for gyros to stabilize
	adc_init();
	sensor_process_flag = 0;
	sensor_flag = 0;

	// print out default sensor values
#ifdef GYRO_AND_DMS_ONLY
	printf("\nBattery = %imV, Gyro X, Y Center = %i %i ", adc_battery_val, adc_gyrox_center, adc_gyroy_center);
#endif
#ifdef ACCEL_AND_ULTRASONIC
	printf("\nBattery, Gyro X, Y Accel X, Y Center = %imV %i %i %i %i", adc_battery_val, adc_gyrox_center, adc_gyroy_center, adc_accelx_center, adc_accely_center);
#endif
	// write out the command prompt
	printf(	"\nReady for command.\n> ");

	// TIMING: timer4 = micros();

	// main command loop (takes 28us when idle)
	// keeps executing unless we encounter a major alarm
    while( !major_alarm )
    {
		// Check if we received a new command
		command_flag = serialReceiveCommand();		// takes 4ms if new command (largely because of printf)

		// TIMING: timer1 = micros() - timer4;
		
		// see if we are in a wait command
		if ( bioloid_command == COMMAND_WAIT_MILLISECONDS || bioloid_command == COMMAND_WAIT_SECONDS )
		{
			// first look if we should continue waiting
			if ( wait_flag == 1 )
			{
				// check timer 
				if ( millis() - wait_timer > wait_time )
				{
					// wait time is finished - reset the wait flag, timer and time
					wait_flag = 0;
					wait_timer = 0;
					wait_time = 0;
					// read next command from command sequence 
					if ( flag_motion_sequence == 1 )
					{
						bioloid_command = command_sequence_buffer[command_sequence_counter][0];
						next_motion_page = command_sequence_buffer[command_sequence_counter][1];
						// update pointer if there are more commands left
						if ( command_sequence_counter < command_sequence_length ) { 
							command_sequence_counter++; 
						} else {
							// sequence is finished, reset all sequence related variables
							flag_motion_sequence = 0;
							command_sequence_counter = 0;
							command_sequence_length = 0;
							bioloid_command = COMMAND_STOP;
						}
					}
				}
			}
			
			if ( command_flag == 1 && wait_flag == 0 ) {
				// wait command has only just been received, calculate wait time
				wait_timer = millis();
				command_flag = 0;
				wait_flag = 1;
				wait_time = next_motion_page;
			} 
			else if ( command_flag == 1 && wait_flag == 1 )
			{
				// wait command is still in progress but new command has been received
				// check for STOP, otherwise ignore
				if ( bioloid_command == COMMAND_STOP )
				{
					// reset the wait flag, timer and time
					wait_flag = 0;
					wait_timer = 0;
					wait_time = 0;
				}
			}
		} 
		
		// check if start button has been pressed and we need to do emergency stop
		if ( start_button_pressed && bioloid_command != COMMAND_STOP )
		{
			// disable torque & reset current command
			comm_status = dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 0);
			last_bioloid_command = bioloid_command;
			bioloid_command = COMMAND_STOP;
			command_flag = 1;
			// and reset the start button variable
			start_button_pressed = FALSE;
		} else if ( start_button_pressed && bioloid_command == COMMAND_STOP ) {
			// we are resuming from an emergency stop, restore last command
			bioloid_command = last_bioloid_command;
			last_bioloid_command = COMMAND_STOP;
			command_flag = 1;
			// and reset the start button variable
			start_button_pressed = FALSE;
		}
		
		// Check if we need to read the sensors 
		sensor_flag = adc_readSensors();      // takes 0.6ms for gyro/accel and 0.9ms including DMS/ultrasonic (156us per channel)
		if ( sensor_flag == 1 ) {
			// new sensor data - process and update command flag if necessary
			sensor_process_flag = adc_processSensorData();
			if ( command_flag == 0 && sensor_process_flag == 1 ) {
				// robot has slipped, front/back getup command has been issued
				command_flag = 1;
			} else if ( sensor_process_flag == 2 ) {
				// if the sensor process flag = 2 it means low voltage emergency stop
				major_alarm = TRUE;
			}
		}
		
		// obstacle avoidance for walking
		if ( walk_getWalkState() != 0 ) {
			// currently very basic - turn left until path is clear
			obstacle_flag = walk_avoidObstacle(obstacle_flag);
			if ( command_flag == 0 && (obstacle_flag == 1 || obstacle_flag == -1) ) {
				command_flag = 1;
			}
		}
		
		// set the new command global variable
		if( command_flag == 1 ) {
			new_command = TRUE;
			command_flag = 0;
			// if we are coming out of BAL command, reset joint offsets
			if( last_bioloid_command == COMMAND_BALANCE && bioloid_command != COMMAND_BALANCE ) {
				for (uint8 i=0; i<NUM_AX12_SERVOS; i++)	 { joint_offset[i] = 0; }
			}			
		}
		
		// TEST printf("\n Command %i, New %i, MP %i, Next MP %i ", bioloid_command, new_command, current_motion_page, next_motion_page);
		// TIMING: timer2 = micros() - timer4 - timer1;
		
#ifdef ACCEL_AND_ULTRASONIC
		// static balancing
		if ( bioloid_command == COMMAND_BALANCE && major_alarm != TRUE ) {
// static balancing uses Kalman Filter or PID controller depending on availability of accelerometer
			// first make sure the PID is turned on
			if ( pid_getMode() != AUTOMATIC ) { pid_setMode(AUTOMATIC); }
			staticRobotBalance();
		} else if ( pid_getMode() == 1 ) {
			pid_setMode(MANUAL);
		}		
#endif

		// execute motion steps
		if ( major_alarm != TRUE ) {
			motion_flag = executeMotionSequence();	// takes 2.1ms when executing a step during walking or 3.3ms if unpacking a new motion page
		}
		
		// TIMING: timer3 = micros() - timer4 - timer1 - timer2;
		// TIMING: printf("Timer 1 = %lu, 2 = %lu, 3 = %lu, SFlag = %i\n", timer1, timer2, timer3, sensor_flag);
		// TIMING: timer4 = micros();

    } // end of main command loop

}

// There is a bug in the GCC tool chain with AVR Studio 5 (gcc 4.5.1) that causes Flash memory beyond
// 64KB not to be accessed correctly (compiler generates lpm instructions where elpm should be generated)
// for details on this bug see http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=108702
// The code below provides a fix

 void __do_copy_data(void) __attribute__((__section__(".init4"), __naked__)); 
  void __do_copy_data(void) { 
    __asm__( 
   "   ldi r17, hi8(__data_end)                                                 \n" 
   "   ldi r26, lo8(__data_start)                                               \n" 
   "   ldi r27, hi8(__data_start)                                               \n" 
   "   ldi r30, lo8(__data_load_start)                                          \n" 
   "   ldi r31, hi8(__data_load_start)                                          \n" 
   "                                                                            \n" 
   "                                                                            \n" 
   "   ldi r16, hh8(__data_load_start)                                          \n" 
   "   out %[_RAMPZ], r16														\n" 
   "   rjmp  .L__do_copy_data_start                                             \n" 
   " .L__do_copy_data_loop:                                                     \n" 
   "   elpm  r0, Z+                                                             \n" 
   "   st  X+, r0                                                               \n" 
   " .L__do_copy_data_start:                                                    \n" 
   "   cpi r26, lo8(__data_end)                                                 \n" 
   "   cpc r27, r17                                                             \n" 
   "   brne  .L__do_copy_data_loop                                              \n" 
   : 
   :  [_RAMPZ]    "I" (_SFR_IO_ADDR(RAMPZ)) 
    ); 
  } 