/*
 * BioloidCControl.c - Replacement firmware for the Robotis Bioloid CM-510 controller
 *   and Bioloid Premium Kit based humanoid robots (Type A/B/C). 
 * 
 * Requires a motion.h file generated by the translate_motion.pl Perl script.
 *
 * Supports all motions, including walking, gyro, DMS, buzzer, LEDs, buttons and
 * serial connection via cable, ZIG2Serial and RC-100.
 *   
 * Version 0.4		30/09/2011 - finite state machine based control loop
 *
 * Written by Peter Lanius
 * Please send suggestions and bug fixes to peter_lanius@yahoo.com.au
 *
 */

/*
 * You may freely modify and share this code, as long as you keep this
 * notice intact. Licensed under the Creative Commons BY-SA 3.0 license:
 *
 *   http://creativecommons.org/licenses/by-sa/3.0/
 *
 * Disclaimer: To the extent permitted by law, this work is provided
 * without any warranty. It might be defective, in which case you agree
 * to be responsible for all resulting costs and damages.
 */

#include "global.h"			// contains basic hardware defines
#include <avr/io.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include "buzzer.h"
#include "button.h"
#include "led.h"
#include "serial.h"
#include "adc.h"
#include "dynamixel.h"
#include "pose.h"
#include "motion_f.h"
#include "clock.h"
#include <avr/pgmspace.h>
#include <util/delay.h>

// Array showing which Dynamixel servos are enabled (ID from 0 to 25)
#ifdef HUMANOID_TYPEA
const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEB
const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEC
const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,9,10,11,12,13,14,15,16,17,18};
#endif

// set some execution parameters
const uint8 SENSOR_LOOP_MS = 200;		// read sensors every 200ms (max is 255ms)

// store the buzzer melodies in Flash
const char melody1[] PROGMEM = "!L16 cdefgab>cbagfedc";
const char melody2[] PROGMEM = "T240 L8 a gafaeada c+adaeafa";
const char melody3[] PROGMEM = "O6 T40 L16 d#<b<f#<d#<f#<bd#f#";
const char melody4[] PROGMEM = "! O6 L16 dcd<b-d<ad<g d<f+d<gd<ad<b-";
 
// Define global variables for use in the ISRs
// Button related variables
volatile bool button_up_pressed = FALSE;
volatile bool button_down_pressed = FALSE;
volatile bool button_left_pressed = FALSE;
volatile bool button_right_pressed = FALSE;
volatile bool start_button_pressed = FALSE;

// Buzzer related global variables
volatile unsigned char buzzerFinished = 0;	// flag: 0 while playing
const char *buzzerSequence;

// ADC related global variables 
// By default ports are assigned as follows:
//		GyroX = CM-510 Port3 = ADC3 = PORTF3
//		GyroY = CM-510 Port4 = ADC4 = PORTF4
//		DMS   = CM-510 Port5 = ADC5 = PORTF5
volatile uint16 adc_sensor_enable[ADC_CHANNELS] = {0, 0, 1, 1, 1, 0}; 
volatile uint16 adc_sensor_val[ADC_CHANNELS] = {0, 0, 0, 0, 0, 0}; 	// array of sensor values
volatile uint16 adc_battery_val = 0;	// battery voltage in millivolts
volatile uint16 adc_gyrox_center = 0;	// gyro x center values
volatile uint16 adc_gyroy_center = 0;	// gyro y center values

// Global variables related to the finite state machine that governs execution
volatile uint8 bioloid_command = 0;			// current command
volatile uint8 last_bioloid_command = 0;	// last command
volatile uint8 flag_receive_ready = 0;		// received complete command flag

// keep the current pose as global variable
volatile int16 current_pose[NUM_AX12_SERVOS];
// and also the current and last motion pages
volatile uint8 current_motion_page = 0;
volatile uint8 last_motion_page = 0;


// the new implementation of AVR libc does not allow variables passed to _delay_ms
static inline void delay_ms(uint16 count) {
	while(count--) { 
		_delay_ms(1); 
	} 
}


int main(void)
{
	// Initialization Routines
	led_init();			// switches all 6 LEDs on
	buzzer_init();
	button_init();
	serial_init(57600);	// serial port at 57600 baud
	
	// wait 0.5s before switching LEDs off
	for (uint8 i=1; i<=50 ; i++) { _delay_ms(10); }
	led_off(ALL_LED);
	// initialize the ADC and take default readings
	adc_init();
	// initialize the clock
	//clock_init();
	
	// enable interrupts
	sei();
	// print welcome message
	printf("\n\nBioloid C Control V0.4\n");
	// reset the start button variable, something triggers the interrupt on start-up
	start_button_pressed = FALSE;
	
	// print out default sensor values
	printf("Battery, Gyro X, Y Center = %i %i %i \n\n", adc_battery_val, adc_gyrox_center, adc_gyroy_center);
	
	// initialize motion pages
	motionPageInit();
	
	
	// Wait for the START Button before going any further
	while(!start_button_pressed)
	{
		// PLAY LED is flashing at 5Hz
		led_toggle(LED_PLAY);
		delay_ms(200);
	}
	// Now turn LED solid
	led_on(LED_PLAY);

	// start the ADC sensor loop
	adc_enableSensorLoop(SENSOR_LOOP_MS);
	
	// perform high level initialization of Dynamixel bus and servos
	dxl_init(DEFAULT_BAUDNUMBER);

	// assume initial pose
	moveToDefaultPose();

	// test
	unpackMotion(8);
	unpackMotion(22);
	unpackMotion(23);

	// write out the command prompt
	printf(	"Ready for command.\n> ");

	// main loop
    while(1)
    {
		// Check if we received a new command
		SerialReceiveCommand();
		
		// Check for button presses
		if( button_up_pressed ) {
			// switch on top 2 LEDs
			led_off(ALL_LED);
			led_on(LED_MANAGE | LED_TXD);
			
			// play melody 1
			buzzer_playFromProgramSpace(melody1);
			
			// execute a motion - Bow
			//executeMotionSequence(1);
			
			// reset the variable
			button_up_pressed = FALSE;

		} else if( button_down_pressed ) {
			// switch on bottom 2 LEDs
			led_off(ALL_LED);
			led_on(LED_AUX | LED_PLAY);
			
			// play melody 2
			buzzer_playFromProgramSpace(melody2);
			
			// execute a motion - Bravo
			//executeMotionSequence(2);

			// reset the variable
			button_down_pressed = FALSE;
			
		} else if( button_left_pressed ) {
			// switch on left 3 LEDs
			led_off(ALL_LED);
			led_on(LED_MANAGE | LED_PROGRAM | LED_PLAY);
			
			// play melody 3
			buzzer_playFromProgramSpace(melody3);
			
			// execute a motion - Rap chest
			//executeMotionSequence(5);

			// reset the variable
			button_left_pressed = FALSE;
			
		} else if( button_right_pressed ) {
			// switch on right 3 LEDs
			led_off(ALL_LED);
			led_on(LED_TXD | LED_RXD | LED_AUX);
			
			// play melody 4
			buzzer_playFromProgramSpace(melody4);
			
			// execute a motion - Sit Down
			//executeMotionSequence(25);

			// reset the variable
			button_right_pressed = FALSE;
		}
		
    } // end of main while loop

}